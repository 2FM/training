= LINUX DE NUESTRO LADO
=================
:imagesdir: images
:library: Asciidoctor
:idprefix:
:numbered:

Linux es un sistema operativo muy maleable y es que al ser un sistema operativo basado en licencia open source hay distribuciones prácticamente para cada aspecto profesional que se le ocurra, desde una distribución especializada para fotógrafos hasta herramientas para prueba de penetración _pentest_ y seguridad informática y es que Linux se ha convirtiendo en la mejor opción para hallar vulnerabilidades en un sistema, un pentest es un ataque a un sistema informático con el fin de encontrar brechas de seguridad en las que se podría tener acceso a ella, a su información o incluso controlarla remotamente, todas las problemas de seguridad hallados a través de un pentest deben ser notificados al propietario del sistema afectado, con los resultados de estos pentest se evalúan los potenciales impactos a la seguridad e integridad de la información y sugerir medidas para contrarrestar los ataques

.Logo de Linux:[Imagen tomada de http://www.unixforum.co.uk/[Foro UNIX]]
image::Linux-header.jpg[]

== ¿Qué es una inyección SQL?
=================
Un ataque por inyección SQL como su nombre lo indica consiste en la “inyección” de una consulta SQL por medio de los datos desde el cliente hacia un servidor. Como dijimos anteriormente una base de datos puede contener información sensible de un usuario y un ataque exitoso puede indicarle al servidor que revele esta información a un atacante o no solo revelarla, podría editar, insertar o eliminar datos.
La inyección SQL es común en aplicaciones PHP y ASP esto debido a interfaces con funcionalidades obsoletas, la gravedad de un ataque depende en gran medida de la creatividad del atacante y en menor medida a las contramedidas tomadas para repeler el ataque.
¿Cómo explotar estas características?
Este tipo de ataque se puede realizar de dos formas, ya sea desde un campo de formulario o desde una URL y puede realizar varias acciones, desde un ingreso por contraseña, hasta revelar información


¿Cómo ingresar por medio de un ataque?::
=================
En este ejemplo vamos por medio de un ataque de inyección SQL ingresar a un usuario:

.Inyección a un formulario
image::Paso1.gif[]

¿Qué paso?::
=================
El código usado para realizar este ingreso sin tener contraseña alguna fue (‘Or’ 1 = 1) y lo que le está indicando a la base de datos es básicamente una sentencia que siempre es verdadera, el problema para la explotación de este ataque _Blind SQL injection_ es que realiza la búsqueda de usuarios carácter por carácter, así por ejemplo, si la contraseña es “Hola” el código ingresado testea letra por letra y acumula en caso de un resultado positivo, de esta manera va guardando la “H”, luego la “o” hasta dar con la palabra completa.

Otro tipo de ataque puede darse por inyección en las URL mostrado a continuación:

.Inyección a una URL
image::Paso2.gif[]

El código a usar es (’UNION ALL SELECT username, password FROM members WHERE admin=1--) Como se puede observar es una petición pidiendo al servidor que revele quienes tienen el estatus de administrador en otras palabras “administrador=1”. Directamente el servidor interpreta que debe mostrar al(los) usuario(s) que son administradores, pero además del usuario necesitamos la contraseña que se puede obtener de la siguiente manera:

.Inyección a una URL
image::Paso3.gif[]

El código a usar es similar al de detectar al administrador (’UNION ALL SELECT password, 2 FROM members WHERE username=’bellamond’--) al igual que el anterior es simplemente indicarle al servidor que me muestre la contraseña del administrador para lograr entrar a su cuenta, aunque la contraseña este en SHA1 lo grave es que el servidor permitió ver la contraseña de un administrador

¿Cómo evitar este tipo de ataque?::
=================
El principal punto débil de estos ataques es que si dejamos que un usuario ingrese cualquier tipo de carácter sin control -para realizar el ataque usamos comilla sencilla- un atacante podría aprovecharse de las comillas para declarar cadenas de texto que interpreta un servidor.
Por lo tanto, la solución estándar para evitar que un atacante realice una consulta es transformarlas comillas antes de que ingresen al servidor por ejemplo una comilla doble debe transformarse a (\”) y así el servidor interpretara esto como una comilla doble y no como una solicitud para iniciar una consulta, para hacer esto se programa según el lenguaje.

En Perl::
=================
El método quote filtra los caracteres especiales -Esto asumiendo que una variable $sql hace referencia a un objeto DBI-

[source,perl]
----  
$query = $sql->prepare 
   ( 
         "SELECT * FROM usuarios WHERE nombre = " 
     . 
         $sql->quote($nombre_usuario) 
    );
---- 

En PHP::
=================
La manera más utilizada para evitar este ataque si se está usando MYSQL es con la función mysql_real_escape_string, la cual coloca barras invertidas ante los siguientes caracteres:  \x00, \n, \r, \', \" y \x1a. Con lo cual garantiza que los datos sean seguros antes de enviar una consulta a MySQL

[source,php]
---- 
<?php
$enlace = mysql_connect('mysql_host', 'mysql_usuario', 'mysql_contrasenya')
    OR die(mysql_error());
$query = sprintf("SELECT * FROM usuarios WHERE usuario='%s' AND
     password='%s'",
            mysql_real_escape_string($usuario),
            mysql_real_escape_string($password));
?>
----

Y en caso de usar MySQLi

[source,php]
----
$conexion = mysqli_connect("host", "usuario", "clave", "bdd");
$query = mysqli_query($conexion, "SELECT * FROM usuarios WHERE nombre = '" . mysqli_real_escape_string($conexion, $nombre) . "'");
$query = $this->query("SELECT * FROM usuarios WHERE nombre = '" . $this->real_escape_string( $nombre ) . "'");
$query = $this->mysqli->query("SELECT * FROM usuarios WHERE nombre = '" . $this->mysqli->real_escape_string($nombre) . "'");
----

No obstante, es recomendado utilizar PDO que ya ofrecen consultas preparadas

[source,php]
----
$statement = $pdo->prepare("SELECT * FROM usuarios WHERE nombre = :nombre");
$statement->bindParam(':nombre', $nombre_usuario);
$statement->execute();
$result = $statement->fetch();
----

Ruby on Rails (RoR)::

En RoR las consultas son verificadas automáticamente por cualquiera de los métodos de búsqueda incluidos

[source,ruby]
----
Project.find consulta := "SELECT * FROM usuarios WHERE nombre = '" + nombreUsuario + "';"
----

Estos ataques se pueden evitar en muchos lenguajes distintos, e incluso hay lenguajes que por defecto aumenta la dificultad al ataqcante para explotar esta vulnerabilidad, pero lo que se debe tener en cuenta es que donde hay una consulta SQL existe una vulnerabilidad a nuestro sistema.

= Referencia
. http://php.net/manual/es/security.database.sql-injection.php[PHP]
. https://technet.microsoft.com/es-es/library/ms161953(v=sql.105).aspx[Microsoft Technet]
