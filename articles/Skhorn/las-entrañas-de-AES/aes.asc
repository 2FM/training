= Las entrañas de AES

== El origen de AES (Advanced encryption Standard)

En 1997 la NIST(National Institute of Standards and Technology) realizó una convocatoria para reemplazar el algoritmo de cifrado DES(Data encryption Standard), entre 15 equipos, 5 finalistas, el algoritmo seleccionado fue Rijndael, el sucesor de DES y el candidato para AES. 

[NOTE]
=====================================================================
En este artículo no se tratara Rijndael, ya que maneja diferentes tamaños de bloques y longitud de claves que no son las adoptadas por AES. 
=====================================================================


AES es un algoritmo de cifrado simétrico por bloques, que puede procesar bloques de datos de *128 bits*, usando claves con una longitud de *128*, *192* y *256 bits*. La estructura de este y de otros algoritmos de cifrado simétrico son complejos y no son fáciles de explicar, ya que tienen una fundamentación matemática muy fuerte, pero tratare de explicar por lo menos cuales son los procesos internos que realiza el algoritmo.

--------------------------------------
 Llevar esto: *Cifrando con AES*

 a esto: *ff0b844a0853bf7c6934ab4364148fb9*
--------------------------------------

== Consideraciones, aclaraciones o conceptos que deben mencionarse.

. *bit* el digito binario, que solo tiene dos valores, 1 o 0.

. *byte* un grupo de *8 bits* que es considerado como una sola entidad. *1byte = 8bits*. e.g C = 01000011

. *Nb* número de columnas (Palabras de 32-bits) que comprenden el *_State_*.

. *Expansion key* rutina usada para generar series de *Round keys* de la clave original

. *_State_* un cifrado intermedio que puede verse como una matriz de 4 filas con *Nb* columnas.

. *_S-Box_* tabla de sustitución usada en varios pasos de transformación y de expansión de la clave.

. *_GF_* campos finitos de galois.

. *_XOR_/⊕* la operación lógica bit a bit.

== Longitud de claves

Especificación de la longitud de la clave (*128*, *192*, *256* bits).

--------------------------------------
*n* = clave

* Longitud de clave = 128 bits; *n < 16 bytes*

* Longitud de clave = 192 bits; *n < 24 bytes*

* Longitud de clave = 256 bits; *n < 32 bytes*
--------------------------------------

[NOTE]
=====================================================================
Si la clave es menor que la longitud máxima especificada, se rellena con caracteres nulos. ****VERIFICAR**** 
=====================================================================



== Estructura de AES

Las entradas de los algoritmos de cifrado y descifrado, es un solo bloque de 128 bits el bloque se representa como una matriz cuadrada de 4 x 4, donde el ordenamiento de la entrada en la matriz es por columnas, 

e.g:
Si nuestro mensaje es *Cifrando con AES* (*Tomando en cuenta los espacios en blanco!*), en su representación hexadecimal: *43696672616e646f20636f6e20414553*

.El ordenamiento por columnas, seria asi, si nuestro mensaje es de la forma = {b0 b1 b2 b3 b4... bi} Donde i < 16: 
[cols="h,4*",options="header",width="50%"]
|==========================================
|b0|b4|b8 |b12
|b1|b5|b9 |b13
|b2|b6|b10|b14
|b3|b7|b11|b15
|==========================================

.Siguiendo lo anterior, el resultado sería una matriz de 4 x 4:
[cols="h,4*",options="header",width="50%"]
|==========================================
|43|61|20|20   
|69|6e|63|41   
|66|64|6f|45   
|72|6f|6e|53   
|==========================================

Similarmente esto pasa con nuestra llave. Retomando lo anterior, el bloque inicial es copiado en una matriz de estados de 4 x 4 donde sufre diferentes transformaciones durante el cifrado o el descifrado y finalmente, como resultado obtenemos una matriz de 4 x 4. Las operaciones del cifrado consisten en *N* rondas, donde la cantidad de rondas dependen del tamaño de la clave:

* *N* = 10; 10 rondas para una clave de 16 bytes
* *N* = 12; 12 rondas para una clave de 24 bytes
* *N* = 14; 14 rondas para una clave de 32 bytes

Las primeras, *N-1* rondas consisten en 4 distintas funciones de transformación: SubBytes, ShiftRows, MixColumns y el AddRoundKey, que las describire en un momento. La ultima ronda consiste solo de tres transformaciones y hay una transformación inicial (AddRoundKey) antes de la primera ronda, que la consideramos como la Ronda 0. En pocas palabras, entra una matriz de 4 x 4, sale una matriz de 4 x 4 que fue transformadad multiples veces.

image::/articles/Skhorn/las-entrañas-de-AES/aes-resume-steps.png[]

== Transformaciones durante cifrado y descifrado

* *SubBytes* - *Sustitución de Bytes*

Durante el cifrado, en cada ronda, los valores de la matriz, son sustituidos con su correspondiente valor en una tabla, llamada S-Box.

image::/articles/Skhorn/las-entrañas-de-AES/aes-s-box.png[]

e.g si la matriz en la posición [0][0] es A9, buscamos el valor correspondiente en la S-Box, que sería D3 y lo reemplazamos. Como hacemos esto? Primero buscamos el primer digito por columna, en este caso, la A, ahora buscamos el segundo digito por fila y nos fijamos en el valor correspondiente, la intersección de estos valores nos da como resultado D3.

* *ShiftRows* - *Permutaciones*

En este estado, cada fila de la matriz realiza un cambio de fila circular, esto significa, que en cada fila, cada byte se mueve ciertos espacios, uno sobre otro. La rotación se determina de esta manera:

* Fila 0 : Rotación = 0
* Fila 1 : Rotación = 1
* Fila 2 : Rotación = 2
* Fila 3 : Rotación = 3

e.g 
[width="50%", cols="a,2a"]
|==========================================
|
|[float]
|Matriz inicial
|~~~~~~~~~~~~~~
|Fila 0 |FD|9C|F2|1A   
|Fila 1 |6A|39|63|D4   
|Fila 2 |CB|C5|63|7D   
|Fila 3 |B1|7B|C5|47   

.2+|
[float]
ShiftRow aplicado
~~~~~~~~~~~~~~~~~
|FD|9C|F2|1A  
|39|63|D4|6A
|63|7D|CB|C5
|47|B1|7B|C5
|==========================================


* *MixColumns*
Este paso es el mas dispendioso y mas dificil de entender y explicar. Consiste de dos partes. La primera, una multiplicación de matrices, entre la matriz en dicho estado contra una matriz de multiplicación y la segunda parte, es como se implementa esta multiplicación sobre los campos de Galois (_GF_).

** *Multiplicación de columnas

La multiplicación es efectuada una columna a la vez (4 bytes), donde cada valor es multiplicado contra cada valor en la fila de la matriz de multiplicación, (16 multiplicaciones). En cada resultado de estas multiplicaciones se efectua un *XOR* para producir los nuevos 4 bytes para el siguiente estado de la matriz.


[width="50%", cols="a,2a"]
|==========================================
|
[float]
Matriz de multiplicación
~~~~~~~~~~~~~~~~~~~~~~~~
|02|03|01|01   
|01|02|03|01   
|01|01|02|03   
|03|01|01|02   

.2+|
[float]
Matriz de estados
~~~~~~~~~~~~~~~~~
|b0|b4|b8 |b12
|b1|b5|b9 |b13
|b2|b6|b10|b14
|b3|b7|b11|b15
|==========================================

El primer byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de estados, contra los 4 valores de la primera fila de la matriz de multiplicación, al resultado de cada multiplicación se le efectua un XOR para asi 1 byte.

b0 = (b0 * 02) XOR (b1 * 03) XOR (b2 * 01) XOR (b3 * 01)

El segundo byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de estados, contra los 4 valores de la segunda fila de la matriz de multiplicación y al resultado de cada multiplicación se le efectua un XOR para así generar 1 byte.

b1 = (b0 * 01) XOR (b1 * 02) XOR (b2 * 03) XOR (b3 * 01)

El tercer byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de estados, contra los 4 valores de la tercera fila de la matriz de multiplicación y al resultado de cada multiplicación se le efectua un XOR para así generar 1 byte.

b2 = (b0 * 01) XOR (b1 * 01) XOR (b2 * 02) XOR (b3 * 03)

El cuarto byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de estados, contra los 4 valores de la cuarta fila de la matriz de multiplicación y al resultado de cada multiplicación se le efectua un XOR para así generar 1 byte.

b3 = (b0 * 03) XOR (b1 * 01) XOR (b2 * 01) XOR (b3 * 02)

Seguidamente, este proceso se efectua con la proxima columna, hasta que no hayan mas.

Colocando todo esto junto:
-----------------------------------------------
* Primera columna
b0 = (b0 * 02) XOR (b1 * 03) XOR (b2 * 01) XOR (b3 * 01) 
b1 = (b0 * 01) XOR (b1 * 02) XOR (b2 * 03) XOR (b3 * 01) 
b2 = (b0 * 01) XOR (b1 * 01) XOR (b2 * 02) XOR (b3 * 03) 
b3 = (b0 * 03) XOR (b1 * 01) XOR (b2 * 01) XOR (b3 * 02) 

* Segunda columna
b4 = (b4 * 02) XOR (b5 * 03) XOR (b6 * 01) XOR (b7 * 01)
b5 = (b4 * 01) XOR (b5 * 02) XOR (b6 * 03) XOR (b7 * 01)
b6 = (b4 * 01) XOR (b5 * 01) XOR (b6 * 02) XOR (b7 * 03)
b7 = (b4 * 03) XOR (b5 * 01) XOR (b6 * 01) XOR (b7 * 02)

* Tercera columna
b8 = (b8 * 02) XOR (b9 * 03) XOR (b10 * 01) XOR (b11 * 01)
b9 = (b8 * 01) XOR (b9 * 02) XOR (b10 * 03) XOR (b11 * 01)
b10 = (b8 * 01) XOR (b9 * 01) XOR (b10 * 02) XOR (b11 * 03)
b11 = (b8 * 03) XOR (b9 * 01) XOR (b10 * 01) XOR (b11 * 02)

* Cuarta columna
b12 = (b12 * 02) XOR (b13 * 03) XOR (b14 * 01) XOR (b15 * 01)
b13 = (b12 * 01) XOR (b13 * 02) XOR (b14 * 03) XOR (b15 * 01)
b14 = (b12 * 01) XOR (b13 * 01) XOR (b14 * 02) XOR (b15 * 03)
b15 = (b12 * 03) XOR (b13 * 01) XOR (b14 * 01) XOR (b15 * 02)
-----------------------------------------------

** *Multiplicación sobre campos de Galois

Las matematicas de esta parte se las explico en el doctorado. No, siendo serio, no tratare ese tema en este articulo. Solo me concentrare en las operaciones realizadas sobre estas tablas durante la multiplicación.

image::/articles/Skhorn/las-entrañas-de-AES/e-table.png[]

image::/articles/Skhorn/las-entrañas-de-AES/l-table.png[]

El concepto es muy similar al de la fase del S-Box. Tomar un valor hexadecimal y buscar su correspondiente en la tabla, aunque en esta, cuando se realiza la multiplicación, cada par de valores es reemplazado por su correspondiente en la tabla L y se le efectúa una suma (No la operación lógica AND), si el resultado de esta suma, es mayor que el hexadecimal FF (o en notación decimal 255), le restamos FF al resultado hasta que obtengamos un valor menor o igual a FF y por último, este valor resultante, lo buscamos en la tabla E y lo reemplazamos por su correspondiente. Fácil, no?

[NOTE]
=====================================================================
Hay dos excepciones:
* Cualquier valor multiplicado por 1, da como resultado el mismo valor y no se necesita realizar el procedimiento anterior. e.g A5 * 1 = A5

* Cualquier valor multiplicado por cero, nos da cero.
=====================================================================

Quedara mas claro con un ejemplo:

Si la entrada es D4 BF 5D 30 y, b0 = D4, b1 = BF, b2 = 5D, b3 = 30.

Con la matriz de multiplicación:
[cols="h,4*",options="header",width="50%"]
|==========================================
|02|03|01|01   
|01|02|03|01   
|01|01|02|03   
|03|01|01|02  
|==========================================

Tenemos:
--------------------------------------
b1 = (D4 * 02) XOR (BF * 03) XOR (5D * 01) XOR (30 * 01)
   = E(L(D4) + L(02)) XOR E(L(BF) + L(03)) XOR 5D XOR 30
   = E(41 + 19) XOR E(9D + 01) XOR 5D XOR 30
   = E(5A) XOR E(9E) XOR 5D XOR 30
   = B3 XOR DA XOR 5D XOR 30
   = *04*

b2 = (D4 * 1) XOR (BF * 2) XOR (5D * 3) XOR (30 * 1)
   = D4 XOR E(L(BF)+L(02)) XOR E(L(5D)+L(03)) XOR 30
   = D4 XOR E(9D+19) XOR E(88+01) XOR 30
   = D4 XOR E(B6) XOR E(89) XOR 30
   = D4 XOR 65 XOR E7 XOR 30
   = *66*

b3 = (D4 * 1) XOR (BF*1) XOR (5D*2) XOR (30*3)
   = D4 XOR BF XOR E(L(5D)+L(02)) XOR E(L(30)+L(03))
   = D4 XOR BF XOR E(88+19) XOR E(65+01)
   = D4 XOR BF XOR E(A1) XOR E(66)
   = D4 XOR BF XOR BA XOR 50 
   = *81*

b4 = (D4 * 3) XOR (BF*1) XOR (5D*1) XOR (30*2)
   = E(L(D4)+L(3)) XOR BF XOR 5D XOR E(L(30)+L(02))
   = E(41+01) XOR BF XOR 5D XOR E(65+19)
   = E(42) XOR BF XOR 5D XOR E(7E)
   = 67 XOR BF XOR 5D XOR 60
   = *E5*

--------------------------------------



* *AddRoundKey*

Esta transformación es un XOR entre la matriz de estados contra la matriz de la Round key, esto quiere decir, a los 128 bits de la matriz de estados (o los 16 bytes) se les hace un XOR contra los 128 bits de la matriz de la Round Key, (16 bytes), una operación a nivel de bits.

[width="50%", cols="a,3a"]
|==========================================
|
[float]
Matriz de estados
~~~~~~~~~~~~~~~~~~~~~~~~
|45|6F|63|75
|6E|6D|6C|72
|20|65|61|61
|6E|6E|74|20 

.2+|
[float]
Round key
~~~~~~~~~~~~~~~~~
|64|72|67|36
|36|36|6C|6B
|79|62|61|72
|38|6D|73|36
|==========================================

.3+|
[float]
AddRoundKey
~~~~~~~~~~~~~~~~~
|21|1D|04|43
|58|5B|00|19
|59|07|00|13
|56|03|07|16
|==========================================


** *Key expansion* *********FALTA*************

Como se forma la Round key?

** Rotation

** Substitution

** RCon + XOR

w[0] = 64 36 79 38
w[1] = 72 36 62 6d
w[2] = 67 6c 61 73
w[3] = 36 6b 72 36


w[4] = w[0] XOR g(w[3])


w[0] = 64 36 79 38
						
Para calcular g(w[3])
						
w[3] = 36 6b 72 36


1. Rotación: w[3] = 6b 72 36 36


2. Sustitución con S-BOX w[3] = 7f 40 05 05


                              3. XOR entre el valor anterior por un vector constante     
= [7f 40 05 05] XOR [01 00 00 00]
	         
		  4. Realizar un XOR entre el nuevo valor y w[0]
                      7e 40 05 05
w[0]             64 36 79 38
             ------------
             1a 76 7c 3d


w[4]= 1a 76 7c 3d


w[5] = w[4] XOR w[1] = 68 40 1e 50


w[6] = w[5] XOR w[2] = 0f 2c 7f 23


w[7] = w[6] XOR w[3] = 39 47 0d 15



