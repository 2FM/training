= Las entrañas de AES

== El origen de AES (Advanced encryption Standard)

En 1997 la NIST(National Institute of Standards and Technology) realizó una convocatoria para reemplazar el
algoritmo de cifrado DES(Data encryption Standard), entre 15 equipos, 5 finalistas, el algoritmo seleccionado 
fue Rijndael, el sucesor de DES y el candidato para AES. 

AES es un algoritmo de cifrado simétrico por bloques, eso significa que procesa bloques de datos de *128 bits*,
usando claves con una longitud de *128*, *192* y *256 bits*, todas sus operaciones se realizan a un nivel de 
8-bits (1 byte) y las operaciones aritméticas realizadas como adición, sustracción, multiplicación o división se
efectúan sobre campos finitos de Galois (GF). 

La estructura de este y de otros algoritmos de cifrado simétrico son complejos y no son fáciles de explicar, ya 
que tienen una fundamentación matemática muy fuerte, pero tratare de explicar por lo menos cuales son los 
procesos internos que realiza el algoritmo.


[icon="/articles/Skhorn/las-entrañas-de-AES/icons/note.png", caption="Nota"]
=====================================================================
En este artículo no se tratara Rijndael, ya que maneja diferentes tamaños de bloques y longitud de claves que no
son las adoptadas por AES. 
=====================================================================

Tratare de explicar cuales son los procesos que realiza AES para:
--------------------------------------
 Llevar esto: *Cifrando con AES*

 a esto: *ff0b844a0853bf7c6934ab4364148fb9*
--------------------------------------

=== Consideraciones, aclaraciones o conceptos que deben mencionarse.

* *_bit_* el digito binario, que solo tiene dos valores, 1 o 0.

* *_byte_* un grupo de *8 bits* que es considerado como una sola entidad. *1byte = 8bits*. e.g C = 01000011

* *_Nb_* número de columnas (Palabras de 32-bits) que comprenden el *_State_*.

* *_Expansion key_* rutina usada para generar series de *Round keys* de la clave original

* *_State_* un cifrado intermedio que puede verse como una matriz de 4 filas con *Nb* columnas.

* *_S-Box_* tabla de sustitución usada en varios pasos de transformación y de expansión de la clave.

* *_GF_* campos finitos de galois.

* *_XOR_* la operación lógica bit a bit.

=== Longitud de claves

Especificación de la longitud de la clave (*128*, *192*, *256* bits).

--------------------------------------
Sea *n* = clave

* Longitud de clave = 128 bits; *n < 16 bytes*

* Longitud de clave = 192 bits; *n < 24 bytes*

* Longitud de clave = 256 bits; *n < 32 bytes*

De ahí provienen los diferentes sabores de AES: AES-128, AES-192 y AES-256.
--------------------------------------

[icon="/articles/Skhorn/las-entrañas-de-AES/icons/note.png", caption="Nota"]
=====================================================================
Si la clave es menor que la longitud máxima especificada, se rellena con caracteres nulos. ****VERIFICAR**** 
=====================================================================


== Estructura de AES

Las entradas y salidas del algoritmo de AES, consisten en secuencias de 128 bits (Digitos con valores de 0 y 1)
dichas secuencias son a los que nos referimos como bloques y la cantidad de digitos representan la longitud, a 
su vez este bloque se representa como una matriz cuadrada de 4 x 4, donde el ordenamiento de la entrada en la 
matriz es por columnas.

e.g

.El ordenamiento por columnas de nuestro mensaje es de la forma, *{b0 b1 b2 b3 b4... b~i}* Donde _i < 16_ y _b_
es un *byte* (*8 bits*):  
[options="header"]
|==========================================
|b0|b4|b8 |b12
|b1|b5|b9 |b13
|b2|b6|b10|b14
|b3|b7|b11|b15
|==========================================

Si nuestro mensaje es:
-------------------------------------------
_Dans ma nuit où_ 

*Tomando en cuenta los espacios en blanco!*  asdsad

Y su respectiva representación hexadecimal

_44616e73206d61206e756974206fc3b9_
-------------------------------------------

Siguiendo lo anterior, el resultado sería una matriz de 4 x 4, de la siguiente forma:
[options="header"]
|==========================================
|44|20|6e|20   
|61|6d|75|6f   
|6e|61|69|c3   
|73|20|74|b9   
|==========================================

Similarmente esto pasa con nuestra llave. Retomando lo anterior, el bloque de entrada inicial es copiado en una
matriz, llamada matriz de estados (_State_) de 4 x 4 donde sufre diferentes transformaciones durante el cifrado
o el descifrado y finalmente, como resultado obtenemos una matriz de 4 x 4. Las operaciones del cifrado 
consisten en *N* rondas, donde la cantidad de rondas dependen del tamaño de la clave:

* Si *N* = 10; 10 rondas para una clave de 16 bytes
* Si *N* = 12; 12 rondas para una clave de 24 bytes
* Si *N* = 14; 14 rondas para una clave de 32 bytes

Las primeras, *N-1* rondas consisten en 4 distintas funciones de transformación: _SubBytes_, _ShiftRows_, 
_MixColumns_ y el _AddRoundKey_, que las describire en un momento. La ultima ronda consiste solo de tres
transformaciones y hay una transformación inicial (AddRoundKey) antes de la primera ronda, que la consideramos
como la Ronda 0. En pocas palabras, entra una matriz de 4 x 4, sale una matriz de 4 x 4 que fue transformada 
mutliples veces dependiendo de la longitud de la clave.

image::/articles/Skhorn/las-entrañas-de-AES/images/aes-resume-steps.png[]

== Transformaciones durante cifrado y descifrado

* *SubBytes* - *Sustitución de Bytes*

Durante el cifrado, en cada ronda, los valores de la matriz, son sustituidos con su correspondiente valor en una
tabla, llamada S-Box.

image::/articles/Skhorn/las-entrañas-de-AES/images/aes-s-box.png[]

e.g 
Si la matriz en la posición [0][0] es A9, buscamos el valor correspondiente en la S-Box, que sería D3 y lo
reemplazamos. ¿Cómo hacemos esto? Primero buscamos el primer dígito por columna, en este caso, la A, ahora 
buscamos el segundo dígito por fila y nos fijamos en el valor correspondiente, la intersección de estos valores
nos da como resultado D3.

[cols="1,2a"]
|==========================================
|Matriz inicial
|~~~~~~~~~~~~~~
|21|1D|04|43
|58|5B|00|19
|59|07|00|13
|56|03|07|16 

[cols="2,1"]
|Aplicando la sustitución con la S-Box
|~~~~~~~~~~~~~~~~~
!FD!9C!F2!1A
!6A!39!63!D4
!CB!C5!63!7D
!B1!7B!C5!47
!==========================================

|==========================================


image::/articles/Skhorn/las-entrañas-de-AES/images/s-box-image.png[]

* *ShiftRows* - *Permutaciones*

En este estado, cada fila de la matriz realiza un cambio de fila circular, esto significa, que en cada fila,
 cada byte se mueve ciertos espacios, uno sobre otro. La rotación se determina de esta manera:

* Fila 0 : Rotación = 0
* Fila 1 : Rotación = 1
* Fila 2 : Rotación = 2
* Fila 3 : Rotación = 3

e.g 
[cols="1,2a"]
|==========================================
|Matriz inicial
|~~~~~~~~~~~~~~
|Fila 0 |FD|9C|F2|1A   
|Fila 1 |6A|39|63|D4   
|Fila 2 |CB|C5|63|7D   
|Fila 3 |B1|7B|C5|47   

[cols="2,1"]
|ShiftRow aplicado
|~~~~~~~~~~~~~~~~~
!FD!9C!F2!1A  
!39!63!D4!6A
!63!7D!CB!C5
!47!B1!7B!C5
!==========================================

|==========================================

image::/articles/Skhorn/las-entrañas-de-AES/images/shitf-rows-image.png[]

* *MixColumns*
Este paso es el más dispendioso y más difícil de entender y explicar. Consiste de dos partes. La primera, una
multiplicación de matrices, entre la matriz en dicho estado contra una matriz de multiplicación y la segunda
parte, es como se implementa esta multiplicación sobre los campos finitos de Galois (_GF_).

** *Multiplicación de columnas

La multiplicación es efectuada una columna a la vez (4 bytes), donde cada valor es multiplicado contra cada
valor en la fila de la matriz de multiplicación, (16 multiplicaciones). En cada resultado de estas 
multiplicaciones se efectua un *XOR* para producir los nuevos 4 bytes para el siguiente estado de la matriz.


[cols="1,2a"]
|==========================================
|Matriz de multiplicación
|~~~~~~~~~~~~~~~~~~~~~~~~
|02|03|01|01   
|01|02|03|01   
|01|01|02|03   
|03|01|01|02   

[cols="2,1"]
|Matriz de estados
|~~~~~~~~~~~~~~~~~
!==========================================
!b0!b4!b8 !b12
!b1!b5!b9 !b13
!b2!b6!b10!b14
!b3!b7!b11!b15
!==========================================

|==========================================

El primer byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de
estados, contra los 4 valores de la primera fila de la matriz de multiplicación, al resultado de cada
multiplicación se le efectúa un XOR para así 1 byte.

*b0* = (b0 * 02) XOR (b1 * 03) XOR (b2 * 01) XOR (b3 * 01)

El segundo byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de 
estados, contra los 4 valores de la segunda fila de la matriz de multiplicación y al resultado de cada
multiplicación se le efectúa un XOR para así generar 1 byte.

*b1* = (b0 * 01) XOR (b1 * 02) XOR (b2 * 03) XOR (b3 * 01)

El tercer byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de
estados, contra los 4 valores de la tercera fila de la matriz de multiplicación y al resultado de cada
multiplicación se le efectúa un XOR para así generar 1 byte.

*b2* = (b0 * 01) XOR (b1 * 01) XOR (b2 * 02) XOR (b3 * 03)

El cuarto byte resultante es calculado al multiplicar los 4 valores de la primera columna de la matriz de
estados, contra los 4 valores de la cuarta fila de la matriz de multiplicación y al resultado de cada
multiplicación se le efectúa un XOR para así generar 1 byte.

*b3* = (b0 * 03) XOR (b1 * 01) XOR (b2 * 01) XOR (b3 * 02)

Seguidamente, este proceso se efectúa con la próxima columna, hasta que no hayan más.

Colocando todo esto junto:
-----------------------------------------------
* Primera columna
b0 = (b0 * 02) XOR (b1 * 03) XOR (b2 * 01) XOR (b3 * 01) 
b1 = (b0 * 01) XOR (b1 * 02) XOR (b2 * 03) XOR (b3 * 01) 
b2 = (b0 * 01) XOR (b1 * 01) XOR (b2 * 02) XOR (b3 * 03) 
b3 = (b0 * 03) XOR (b1 * 01) XOR (b2 * 01) XOR (b3 * 02) 

* Segunda columna
b4 = (b4 * 02) XOR (b5 * 03) XOR (b6 * 01) XOR (b7 * 01)
b5 = (b4 * 01) XOR (b5 * 02) XOR (b6 * 03) XOR (b7 * 01)
b6 = (b4 * 01) XOR (b5 * 01) XOR (b6 * 02) XOR (b7 * 03)
b7 = (b4 * 03) XOR (b5 * 01) XOR (b6 * 01) XOR (b7 * 02)

* Tercera columna
b8 = (b8 * 02) XOR (b9 * 03) XOR (b10 * 01) XOR (b11 * 01)
b9 = (b8 * 01) XOR (b9 * 02) XOR (b10 * 03) XOR (b11 * 01)
b10 = (b8 * 01) XOR (b9 * 01) XOR (b10 * 02) XOR (b11 * 03)
b11 = (b8 * 03) XOR (b9 * 01) XOR (b10 * 01) XOR (b11 * 02)

* Cuarta columna
b12 = (b12 * 02) XOR (b13 * 03) XOR (b14 * 01) XOR (b15 * 01)
b13 = (b12 * 01) XOR (b13 * 02) XOR (b14 * 03) XOR (b15 * 01)
b14 = (b12 * 01) XOR (b13 * 01) XOR (b14 * 02) XOR (b15 * 03)
b15 = (b12 * 03) XOR (b13 * 01) XOR (b14 * 01) XOR (b15 * 02)
-----------------------------------------------

** *Multiplicación sobre campos de Galois

Las matemáticas de esta parte se las explico en el doctorado. No, siendo serio, no trataré este tema en este
artículo. Solo me concentrare en las operaciones realizadas sobre estas tablas durante la multiplicación.

image::/articles/Skhorn/las-entrañas-de-AES/images/e-table.png[]

image::/articles/Skhorn/las-entrañas-de-AES/images/l-table.png[]

El concepto es muy similar al de la fase del S-Box. Tomar un valor hexadecimal y buscar su correspondiente en la 
tabla, aunque en esta, cuando se realiza la multiplicación, cada par de valores es reemplazado por su 
correspondiente en la tabla *_L_* y se le efectúa una suma (No la operación lógica AND), si el resultado de esta
suma, es mayor que el hexadecimal *_FF_* (o en notación decimal 255), le restamos *_FF_* al resultado hasta que
obtengamos un valor menor o igual a *_FF_* y por último, este valor resultante, lo buscamos en la tabla *_E_* 
y lo reemplazamos por su correspondiente. ¿Fácil, no?

[icon="/articles/Skhorn/las-entrañas-de-AES/icons, caption=NOTE]
=====================================================================
Hay dos excepciones:
* Cualquier valor multiplicado por 1, da como resultado el mismo valor y no se necesita realizar el
procedimiento anterior. e.g A5 * 1 = A5

* Cualquier valor multiplicado por cero, nos da cero.
=====================================================================

Quedará más claro con un ejemplo:

Si la entrada es D4 BF 5D 30 y, b0 = D4, b1 = BF, b2 = 5D, b3 = 30.

Con la matriz de multiplicación respectiva:
[cols="h,4*",options="header"]
|==========================================
|02|03|01|01   
|01|02|03|01   
|01|01|02|03   
|03|01|01|02  
|==========================================

Tenemos:
--------------------------------------
b1 = (D4 * 02) XOR (BF * 03) XOR (5D * 01) XOR (30 * 01)
   = E(L(D4) + L(02)) XOR E(L(BF) + L(03)) XOR 5D XOR 30
   = E(41 + 19) XOR E(9D + 01) XOR 5D XOR 30
   = E(5A) XOR E(9E) XOR 5D XOR 30
   = B3 XOR DA XOR 5D XOR 30
   = *04*

b2 = (D4 * 1) XOR (BF * 2) XOR (5D * 3) XOR (30 * 1)
   = D4 XOR E(L(BF)+L(02)) XOR E(L(5D)+L(03)) XOR 30
   = D4 XOR E(9D+19) XOR E(88+01) XOR 30
   = D4 XOR E(B6) XOR E(89) XOR 30
   = D4 XOR 65 XOR E7 XOR 30
   = *66*

b3 = (D4 * 1) XOR (BF*1) XOR (5D*2) XOR (30*3)
   = D4 XOR BF XOR E(L(5D)+L(02)) XOR E(L(30)+L(03))
   = D4 XOR BF XOR E(88+19) XOR E(65+01)
   = D4 XOR BF XOR E(A1) XOR E(66)
   = D4 XOR BF XOR BA XOR 50 
   = *81*

b4 = (D4 * 3) XOR (BF*1) XOR (5D*1) XOR (30*2)
   = E(L(D4)+L(3)) XOR BF XOR 5D XOR E(L(30)+L(02))
   = E(41+01) XOR BF XOR 5D XOR E(65+19)
   = E(42) XOR BF XOR 5D XOR E(7E)
   = 67 XOR BF XOR 5D XOR 60
   = *E5*

--------------------------------------

* *AddRoundKey*

En la transformación del AddRoundKey, se realiza un XOR entre la _matriz de estados_ contra la matriz de la 
_Round key_, esto quiere decir, que los 128 bits de la matriz de estados (16 bytes) se les hace un XOR contra 
los 128 bits de la matriz de la _Round Key_ (16 bytes), recuerden, esta operación es realizada por cada byte en 
la misma posición en ambas matrices, así que si en la _matriz de estados_ tenemos en la posición [0][0] = 45 y 
en la matriz de la _Round key_ en la misma posición tenemos un 64, entonces realiza la operación del XOR en 
ambos valores, e.g _3D XOR 66_ = 21.

Un ejemplo más grande:

[cols="1,3a"]
|==========================================
|Matriz de estados
|~~~~~~~~~~~~~~~~~~~~~~~~
|45|6F|63|75
|6E|6D|6C|72
|20|65|61|61
|6E|6E|74|20 

[cols="2,1"]
|Round key
~~~~~~~~~~~~~~~~~
!64!72!67!36
!36!36!6C!6B
!79!62!61!72
!38!6D!73!36
!==========================================

|==========================================

[cols="3,1"]
|AddRoundKey
|~~~~~~~~~~~~~~~~~
!21!1D!04!43
!58!5B!00!19
!59!07!00!13
!56!03!07!16
!==========================================

|==========================================

** *Key expansion* 

¿De dónde sale este Round Key?

El _Round key_ es una serie de sub-transformaciones derivadas de las anteriormente mencionadas: _SubBytes_,
_ShiftRows_ y _MixColumns_, dicha transformación es llamada _expansión de la clave_ ó _Key expansion_, toma como
entrada una clave de cuatro palabras (En la literatura se refieren a las cuatro palabras ó _four-words_ para dar
a entender que cada 'palabra' es por decir una columna, si tomamos la representación de esta entrada como una 
matriz de 4 x 4 como mencione al inicio y cada una de estas columnas con 4 dígitos, donde cada digito consiste 
en 1 byte, dando en total 16 bytes) y produce un arreglo lineal de 44 palabras (176 bytes; 16 bytes * 11 Rondas 
= 176 bytes), el cual es suficiente para proveer al _Round Key_ inicial y a las siguientes 10 rondas del 
cifrado. 

El proceso comienza copiando la clave en las primeras cuatro palabras de la _expansion key_ y el resto de la 
_expansión key_ es rellenado cuatro palabras a la vez, donde cada palabra por _Round Key_ que se añade, cada 
w[i], depende inmediatamente de las sub-transformaciones resultantes aplicadas sobre w[i-1] y w[i-4] y las
siguientes tres operaciones son un simple XOR.

Para explicar el proceso de las sub-transformaciones, usare una definición convencional, el símbolo _g_ que 
denota estas complejas transformaciones y consta de lo siguiente:

. ** RotWord: Se realiza una rotación circular de un byte a la izquierda en una palabra, esto quiere decir que
si tenemos esto [B0, B1, B2, B3] la rotación nos lo dejara asi [B1, B2, B3, B0].

. ** SubWord

Usamos la misma tabla S-Box para realizar la sustitución, si tenemos esto [6b, 72, 36, 36], buscamos los valores
correspondiente en la tabla S-Box y nos da como resultado la transformación, [7F, 40, 05, 05].

. ** Rcon
Al anterior resultado obtenido, se le aplica un XOR por un valor constante de ronda o un vector generador,el Rcon
[j], consiste de una palabra cuyos tres octetos más a la derecha son siempre 0, [Rcon[j], 0, 0 , 0]. El efecto
de realizar un XOR con el Rcon, es solo para realizarlo con el byte más a la izquierda. Cada valor en el Rcon[j]
es diferente por cada ronda y sigue esta tabla:

[cols="h,4*",options="header"]
|==========================================
|   j   |1 | 2| 3| 4| 5| 6| 7| 8| 9|10   
|Rcon[j]|01|02|04|08|10|20|40|80|1B|36    
|==========================================

. ** XOR
Al resultado obtenido por el Rcon se le hace un XOR con la primera columna de la _Round Key_, w[0].

Un ejemplo de todo este proceso del _expansion key_, debería dejarlo un poco más claro:

Si nuestra clave es,
[cols="h,4*",options="header"]
|==========================================
|64|72|67|36
|36|36|6C|6B
|79|62|61|72
|38|6D|73|36
|==========================================

Donde cada w[i] toma 4 bytes por columna:

w[0] = 64 36 79 38
w[1] = 72 36 62 6d
w[2] = 67 6c 61 73
w[3] = 36 6b 72 36

El proceso para generar la primera columna de la _Round Key_, donde esta primera sigue el proceso descrito
anteriormente.

Sea w[4] la primer columna de la _Round Key_ generada por la _expansion key_
w[4] = w[0] XOR g(w[3])

Si, w[0] = [64 36 79 38]
						
Para calcular g(w[3]):
						
Si, w[3] = [36 6b 72 36]

. Rotación: w[3] = [6b 72 36 36]

. Sustitución con S-Box sobre RotWord(w[3]) = [7f 40 05 05]

. XOR entre el valor anterior por el Rcon[j], donde Rcon[1] = 01.

			 [7f 40 05 05] XOR [01 00 00 00] = [7E 40 05 05]
	         
. Por último un XOR entre el ultimo resultado valor y w[0]

                      [7e 40 05 05] XOR [64 36 79 38] = [1a 76 7c 3d]
             
Por lo tanto, después de estas transformaciones

w[4]= [1a 76 7c 3d]

Y como se mencionó, las siguientes tres son simples XOR:

w[5] = w[4] XOR w[1] = 68 40 1e 50

w[6] = w[5] XOR w[2] = 0f 2c 7f 23

w[7] = w[6] XOR w[3] = 39 47 0d 15

[cols="h,4*",options="header"]
|==========================================
|1A|68|0F|39
|76|40|2C|47
|7C|1E|7F|0D
|3D|50|23|15
|==========================================

== En resumen, la estructura de AES

. La llave proporcionada como entrada es expandida en un array de 44, palabras de 32-bits, w[i], donde cuatro 
palabras distintas (128 bits) sirven como _Round Key_ para cada ronda.

. Cuatro diferentes operaciones son realizadas, una permutación y tres sustituciones: 
	.. _SubBytes_: Usando la S-Box se realiza una sustitución byte a byte del bloque.
	.. _ShitRows_: Una simple permutación
	.. _MixColumns_: Una sustitución que hace uso de la aritmética sobre campos finitos de Galois.
	.. _AddRoundKey_: Un XOR con el bloque actual con respecto a una porción de la clave de expansión.

. La estructura es simple. Tanto como para cifrar y para el descifrar, se comienza con una fase del AddRoundKey,
seguida de nueve rondas, donde cada una incluye las cuatro operaciones realizadas, seguidas de una décima ronda
de tres fases.

. Solo la fase del AddRoundKey use la llave. Por esta razón el cifrado comienza y termina con una fase del 
AddRoundKey_. Cualquier otra fase aplicada al principio o al final, es reversible sin conocer la clave, por lo 
anto no añadiría seguridad.

. Por si sola, la fase del AddRoundKey no es tan formidable. Las otras tres fases están para crear confusión, 
difusión y no linealidad en salida, pero, por ellos solos no habría seguridad porque no harían uso de la clave.
Este cifrado lo podemos ver como operaciones alternantes de cifrado con XOR (AddRoundKey) de un bloque, seguido 
con un bloque transformado varias veces (Las otras tres fases).

. La ronda final, consiste en solo tres fases. Es requerida para hacer que el cifrado sea reversible (Descifrado).

. Cada fase es fácilmente reversible. Para la sustitución de bytes, la permutación, multiplicación de columnas,
en el proceso de descifrado, hay funciones inversas usadas por el algoritmo de descifrado. Para la fase del 
AddRoundKey, la inversa es lograda haciendo un XOR de la misma Round Key contra el bloque. *A XOR B XOR B = A*.
Cabe destacar, que aunque se usan funciones inversas para descifrar, el algoritmo de descifrado no es idéntico
al de cifrado, lo cual hace que _AES_ tenga una estructura particular.

Los desarrolladores de Rijndael (AES), diseñaron el algoritmo de expansión de clave para ser resistente a 
conocidos ataques de criptoanálisis. La inclusión de la dependencia de cada ronda por una constante de ronda 
elimina la simetría o la similaridad entre las formas en las que se genera cada _Round Key_. El criterio 
especificado para esto, fue:

* El conocer una parte de la clave o de una Round Key no permite conocer el resto de las Round Key generadas.

* Velocidad en una amplia variedad de procesadores.

* Difusión de la clave durante cada Round Key, es decir, un solo bit de la clave afecta muchos bits de las Round
Key siguientes.

== Conclusión

Su pareja esta jodiendo mucho? Sus hijos necesitan un castigo? Ponganles a cifrar manualmente 16 bytes con AES.
No, mentiras, hablando seriamente, este articulo tuvo la intención de tratar de explicar que procesos realiza 
AES para cifrar, sin ahondar en la complejidad matematica, desde el 2001 hasta hoy no han sido capaz de 
romperlo y hay muchos investigadores que rodean este tema, asi que si alguien les dice que rompio AES, 
preguntele primero si la clave era muy facil de adivinar por medio de ingenieria social o era tan corta que por 
fuerza bruta le tomo 1 día.
